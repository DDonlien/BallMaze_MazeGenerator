<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Maze Viewer V2</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; color: #fff; font-family: monospace; }
        #ui { position: absolute; top: 10px; left: 10px; padding: 15px; background: rgba(0,0,0,0.85); border-radius: 8px; border: 1px solid #444; pointer-events: none; min-width: 250px; }
        #dropzone { border: 2px dashed #666; padding: 30px; text-align: center; cursor: pointer; color: #aaa; pointer-events: auto; }
        #dropzone.hover { border-color: #0f0; background: #333; color: #fff; }
        #stats { margin-top: 10px; font-size: 12px; line-height: 1.5; }
        #info-content { margin-top: 15px; border-top: 1px solid #666; padding-top: 10px; display: none; }
        .info-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .info-label { color: #888; }
        .info-val { color: #fff; font-weight: bold; text-align: right; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui">
        <h3>Maze Inspector V2</h3>
        <div id="dropzone">Drop 'generated_maze_v2.json' here</div>
        <div id="stats">Ready</div>
        <div id="info-content"></div>
    </div>

    <script type="module">
        // ==========================================
        // 1. 基础配置与依赖 (Basic Config & Imports)
        // ==========================================

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 1.1 全局常量
        // 修正 3.1: 比例 16cm
        const GRID_SCALE = 16.0;
        // 迷宫边界 (需与 Python MAZE_BOUNDS 保持一致)
        const MAZE_BOUNDS = { x: 4, y: 4, z: 1 };

        // ==========================================
        // 2. 场景初始化 (Scene Initialization)
        // ==========================================

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // 2.1 调试辅助网格 (Debug Grid)
        // 每格 16 单位 - on XY plane
        const gridSize = 3200; // 足够大的范围，且是 16 的倍数
        const gridDivisions = gridSize / GRID_SCALE;
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
        gridHelper.rotation.x = Math.PI / 2;
        // Shift grid so (0,0,0) is center of a cell
        gridHelper.position.set(GRID_SCALE/2, GRID_SCALE/2, 0);
        scene.add(gridHelper);
        
        // 2.2 坐标轴辅助
        const axesHelper = new THREE.AxesHelper(50);
        // UE (Left-Handed) Y is Right. Three.js (Right-Handed) Y is Up (or Left if Z-up).
        // We mapped UE +Y to Three -Y to preserve geometry.
        // So we invert the AxesHelper Y so the Green arrow points to UE +Y (Logical Right).
        axesHelper.scale.set(1, -1, 1);
        scene.add(axesHelper);

        // 2.3 相机与渲染器
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
        camera.up.set(0, 0, 1); // Z-up
        camera.position.set(100, -100, 100); // Adjust default view

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 2.4 灯光系统
        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(50, 200, 100);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // ==========================================
        // 3. 拖拽与文件解析 (Drag & Drop & Parsing)
        // ==========================================

        // 3.1 拖拽事件绑定
        const dz = document.getElementById('dropzone');
        dz.ondragover = (e) => { e.preventDefault(); dz.classList.add('hover'); };
        dz.ondragleave = () => dz.classList.remove('hover');
        dz.ondrop = (e) => {
            e.preventDefault();
            dz.classList.remove('hover');
            const file = e.dataTransfer.files[0];
            const reader = new FileReader();
            reader.onload = (ev) => parseMaze(ev.target.result);
            reader.readAsText(file);
        };

        // 3.2 JSON 解析
        function parseMaze(jsonStr) {
            try {
                const data = JSON.parse(jsonStr);
                buildScene(data);
            } catch (err) {
                alert("JSON Error: " + err);
            }
        }

        // ==========================================
        // 4. 资源管理 (Resource Management)
        // ==========================================

        // 4.1 共享几何体与材质 (Shared Geometries & Materials)
        // 用于优化 InstancedMesh 性能
        
        // Define Flat Arrow Geometries
        // Shaft: Box 1.5 wide, 1.0 high (unit), 0.4 thick
        const flatArrowShaftGeo = new THREE.BoxGeometry(1.5, 1.0, 0.4);
        flatArrowShaftGeo.translate(0, 0.5, 0); // Base at 0
        
        // Head: Extruded Triangle
        const headShape = new THREE.Shape();
        headShape.moveTo(-2.0, 0);
        headShape.lineTo(2.0, 0);
        headShape.lineTo(0, 1.0); // Tip at 1.0 height
        headShape.lineTo(-2.0, 0);
        
        const flatArrowHeadGeo = new THREE.ExtrudeGeometry(headShape, {
            depth: 0.4,
            bevelEnabled: false
        });
        // Extrude creates depth along Z. Center it.
        // Default creates mesh from Z=0 to Z=depth.
        flatArrowHeadGeo.translate(0, 0, -0.2); // Center thickness at Z=0
        
        const sharedGeos = {
            arrowShaft: flatArrowShaftGeo, 
            arrowHead: flatArrowHeadGeo, 
            exitSphere: new THREE.SphereGeometry(0.7, 8, 8),
            boxCache: {} // Cache box geometries by size string "x_y_z"
        };
        
        const sharedMats = {
            green: new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
            red: new THREE.MeshLambertMaterial({ color: 0xff0000 }),
            greenBasic: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
            redBasic: new THREE.MeshBasicMaterial({ color: 0xff0000 }),
            line: new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }),
            boxMatCache: {} // Cache box materials by color
        };

        // 4.2 资源清理函数
        function cleanScene(rootGroup) {
            if (!rootGroup) return;
            // Remove from scene
            scene.remove(rootGroup);
            
            // Dispose dynamic resources explicitly
            disposeCache();
        }
        
        function disposeCache() {
            // 1. Dispose Box Geometries
            Object.values(sharedGeos.boxCache).forEach(g => g.dispose());
            sharedGeos.boxCache = {};
            
            // 2. Dispose Materials (including Text Textures)
            Object.values(sharedMats.boxMatCache).forEach(m => {
                if (m.map) m.map.dispose();
                m.dispose();
            });
            sharedMats.boxMatCache = {};
        }

        // 4.3 全局状态映射
        // Global Sprite Map for fast access
        window.spriteMap = {};
        window.railDataMap = {};
        window.railArrowMap = {};
        window.lastHoveredSprite = null;
        window.lastHoveredArrowIndices = []; // To reset colors
        window.arrowMatrixCache = {}; // Cache for original arrow matrices

        // 4.4 辅助工具
        // Helper for precision
        function formatFloat(val) {
            if (typeof val !== 'number') return val;
            return parseFloat(val.toFixed(8));
        }

        // ==========================================
        // 5. 场景构建核心 (Scene Building Core)
        // ==========================================

        function buildScene(data) {
            // 5.1 清理旧场景
            // Cleanup previous
            const toRemove = [];
            scene.traverse(c => { if(c.name === "MazeRoot") toRemove.push(c); });
            toRemove.forEach(c => cleanScene(c));
            
            // Re-init Sprite Map
            window.spriteMap = {};
            window.railDataMap = {};
            window.railArrowMap = {};
            window.lastHoveredArrowIndices = [];

            const root = new THREE.Group();
            root.name = "MazeRoot";
            const rails = data.Rail;

            // 5.2 更新 UI 统计信息
            // Stats Update
            const totalDiff = data.MapMeta.MazeDiff ? formatFloat(data.MapMeta.MazeDiff) : "N/A";
            
            document.getElementById('stats').innerHTML = 
                `Level: <span style="color:#fff">${data.MapMeta.LevelName}</span><br>` +
                `Count: <span style="color:#fff">${data.MapMeta.RailCount}</span><br>` +
                `Difficulty: <span style="color:#f0a">${totalDiff}</span><br>` +
                `<div style="margin-top:5px; font-size:10px; color:#666">` + 
                `<span style="color:#0f0">●</span> Connected ` +
                `<span style="color:#f00">●</span> Open ` + 
                `<span style="color:#00ffff">●</span> Start <span style="color:#ff00ff">●</span> End` +
                `</div>`;

            // 5.3 绘制迷宫边界框
            // 0. Boundary Box (Revert to Static based on User Request)
            const half = GRID_SCALE / 2;
            const minX = -MAZE_BOUNDS.x * GRID_SCALE - half;
            const maxX =  MAZE_BOUNDS.x * GRID_SCALE + half;
            const minY = -MAZE_BOUNDS.y * GRID_SCALE - half;
            const maxY =  MAZE_BOUNDS.y * GRID_SCALE + half;
            const minZ = -MAZE_BOUNDS.z * GRID_SCALE - half;
            const maxZ =  MAZE_BOUNDS.z * GRID_SCALE + half;

            const boxGeo = new THREE.BoxGeometry(maxX - minX, maxY - minY, maxZ - minZ);
            const edges = new THREE.EdgesGeometry(boxGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineDashedMaterial({ color: 0x666666, dashSize: 4, gapSize: 2 }));
            line.computeLineDistances();
            line.position.set((minX + maxX)/2, (minY + maxY)/2, (minZ + maxZ)/2);
            root.add(line);

            // ==========================================
            // 5.4 实例化网格准备 (Instanced Mesh Prep)
            // ==========================================
            // 1. Analyze Rail Counts by Geometry (Size) - DEPRECATED / UNUSED in new logic
            // We now use a single Unit Cube scaled per instance.

            // 2. Count Arrows & Exits
            let arrowCount = 0;
            let exitCount = 0;
            
            rails.forEach(r => {
                if (r.Prev_Index !== -1) {
                    const prev = rails.find(x => x.Rail_Index === r.Prev_Index);
                    if (prev && prev.Exit.some(e => e.TargetInstanceID === r.Rail_Index)) arrowCount++;
                }
                r.Exit.forEach(ex => {
                    if (ex.Exit_Pos_Abs) {
                        arrowCount++;
                        exitCount++;
                    }
                });
            });

            // ==========================================
            // 5.5 创建实例化网格 (Create Instanced Meshes)
            // ==========================================
            
            // A. Block Instances
            // Use 1 box per rail, scaled.
            const totalBlocks = rails.length;
            
            // Unit cube for scaling
            const standardBoxGeo = new THREE.BoxGeometry(1, 1, 1);
            const standardMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            const blockMesh = new THREE.InstancedMesh(standardBoxGeo, standardMat, totalBlocks);
            
            blockMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            blockMesh.userData.isBlock = true;
            blockMesh.userData.instanceMap = new Array(totalBlocks);
            
            root.add(blockMesh);

            // B. Arrow & Exit Instances
            // CRITICAL: Use White material for InstancedMesh so setColorAt works correctly as a tint!
            const arrowMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const exitMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const shaftIMesh = new THREE.InstancedMesh(sharedGeos.arrowShaft, arrowMat, arrowCount); 
            const headIMesh = new THREE.InstancedMesh(sharedGeos.arrowHead, arrowMat, arrowCount);
            const exitIMesh = new THREE.InstancedMesh(sharedGeos.exitSphere, exitMat, exitCount); 
            
            shaftIMesh.name = "ArrowShaftMesh";
            headIMesh.name = "ArrowHeadMesh";
            exitIMesh.name = "ExitSphereMesh";
            
            shaftIMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            headIMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            exitIMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            
            if (arrowCount > 0) { root.add(shaftIMesh); root.add(headIMesh); }
            if (exitCount > 0) { root.add(exitIMesh); }

            // ==========================================
            // 5.6 填充实例数据 (Populate Instances)
            // ==========================================
            
            const dummy = new THREE.Object3D();
            const colGreen = new THREE.Color(0x00ff00);
            const colRed = new THREE.Color(0xff0000);
            const colGreenBasic = new THREE.Color(0x00ff00);
            const colRedBasic = new THREE.Color(0xff0000);
            
            let arrowIdx = 0;
            let exitIdx = 0;

            // 5.6.1 箭头添加辅助函数
            function getRailBasis(rotAbs) {
                const rx = THREE.MathUtils.degToRad(rotAbs.r || 0);
                const ry = THREE.MathUtils.degToRad(rotAbs.p || 0);
                const rz = THREE.MathUtils.degToRad(rotAbs.y || 0);
                const euler = new THREE.Euler(rx, ry, rz, 'ZYX');
                
                // Default Rail: Forward +X, Up +Z
                const fwd = new THREE.Vector3(1, 0, 0).applyEuler(euler);
                const up = new THREE.Vector3(0, 0, 1).applyEuler(euler);
                return { fwd, up };
            }

            function addArrowInstance(origin, length, isGreen, dir, railUp, railFwd) {
                const headScale = 1.5; 
                const shaftLen = Math.max(0.1, length - headScale);
                const color = isGreen ? colGreen : colRed;

                // Construct Basis
                const vecY = dir.clone().normalize();
                let vecZ = railUp.clone().normalize();
                
                // Check parallel
                if (Math.abs(vecY.dot(vecZ)) > 0.99) {
                    vecZ = railFwd.clone().normalize();
                    if (Math.abs(vecY.dot(vecZ)) > 0.99) {
                        vecZ = new THREE.Vector3(0, 1, 0); 
                    }
                }
                
                const vecX = new THREE.Vector3().crossVectors(vecY, vecZ).normalize();
                vecZ.crossVectors(vecX, vecY).normalize(); 
                
                const rotMat = new THREE.Matrix4().makeBasis(vecX, vecY, vecZ);
                const quat = new THREE.Quaternion().setFromRotationMatrix(rotMat);

                // Shaft
                dummy.scale.set(1, shaftLen, 1);
                dummy.position.copy(origin);
                dummy.quaternion.copy(quat);
                dummy.updateMatrix();
                shaftIMesh.setMatrixAt(arrowIdx, dummy.matrix);
                shaftIMesh.setColorAt(arrowIdx, color);

                // Head
                dummy.scale.set(1, headScale, 1);
                dummy.position.copy(origin).add(dir.clone().multiplyScalar(shaftLen));
                dummy.quaternion.copy(quat);
                dummy.updateMatrix();
                headIMesh.setMatrixAt(arrowIdx, dummy.matrix);
                headIMesh.setColorAt(arrowIdx, color);
                
                arrowIdx++;
            }
            
            // 5.6.2 文本精灵添加辅助函数
            // Helper for Text Sprite (Persistent)
            function addTextSprite(message, pos) {
                if (!sharedMats.boxMatCache["txt_" + message]) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 128;
                    ctx.font = "Bold 60px Arial";
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 4;
                    ctx.strokeText(message, 64, 64);
                    ctx.fillText(message, 64, 64);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const mat = new THREE.SpriteMaterial({ map: texture, depthTest: false });
                    sharedMats.boxMatCache["txt_" + message] = mat;
                }
                
                const sprite = new THREE.Sprite(sharedMats.boxMatCache["txt_" + message]);
                sprite.scale.set(8, 8, 1); // Slightly smaller than before
                sprite.position.copy(pos); // CENTERED: No offset
                sprite.renderOrder = 10;
                sprite.userData = { isText: true, id: message }; // Mark for raycaster
                root.add(sprite);
                
                // Add to Map
                window.spriteMap[message] = sprite;
            }

            // 5.6.3 填充轨道方块 (Populate Blocks)
            let globalBlockIdx = 0;
            const GAP = 1.0; // Gap between rails
            
            rails.forEach(r => {
                // Determine Color
                let colorHex = 0x88ccff; // Light Blue default
                const rid = r.Rail_ID.toLowerCase();
                if (rid.includes("start")) colorHex = 0x00ffff;
                else if (rid.includes("end")) colorHex = 0xff00ff;
                else if (rid.includes("checkpoint")) colorHex = 0xffff00;
                
                const col = new THREE.Color(colorHex);
                
                // Metadata
                const meta = { 
                    id: r.Rail_Index, 
                    type: r.Rail_ID,
                    pos: r.Pos_Abs,
                    pos_rev: r.Pos_Rev,
                    rot: r.Rot_Abs,
                    diff: r.Diff_Act
                };
                
                // Transform
                let cx, cy, cz;
                let useOccupiedSize = false;
                let sizeX, sizeY, sizeZ;

                if (r.Occupied_Cells_Rev && r.Occupied_Cells_Rev.length > 0) {
                    // Calculate center of the bounding box of occupied cells
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;

                    r.Occupied_Cells_Rev.forEach(cell => {
                        // Convert to Three.js coordinates
                        const tx = cell.x * GRID_SCALE;
                        const ty = -cell.y * GRID_SCALE; // Invert Y
                        const tz = cell.z * GRID_SCALE;

                        if (tx < minX) minX = tx;
                        if (tx > maxX) maxX = tx;
                        if (ty < minY) minY = ty;
                        if (ty > maxY) maxY = ty;
                        if (tz < minZ) minZ = tz;
                        if (tz > maxZ) maxZ = tz;
                    });

                    cx = (minX + maxX) / 2;
                    cy = (minY + maxY) / 2;
                    cz = (minZ + maxZ) / 2;
                    
                    // Calculate size from bounds
                    sizeX = (maxX - minX) + GRID_SCALE - GAP;
                    sizeY = (maxY - minY) + GRID_SCALE - GAP;
                    sizeZ = (maxZ - minZ) + GRID_SCALE - GAP;
                    useOccupiedSize = true;
                } else {
                    // Fallback to Pos_Abs if no cell data
                    cx = r.Pos_Abs.x;
                    cy = -r.Pos_Abs.y; // Invert Y
                    cz = r.Pos_Abs.z;
                }
                
                dummy.position.set(cx, cy, cz);
                
                if (useOccupiedSize) {
                    // If we use occupied cells, the box is axis-aligned to the grid.
                    // We DO NOT apply the object's rotation because the occupied cells 
                    // are already the result of the rotation in world space.
                    dummy.rotation.set(0, 0, 0);
                    dummy.scale.set(sizeX, sizeY, sizeZ);
                } else {
                    // Fallback: Use Size_Rev and apply rotation
                    // r.Size_Rev is expected to be {x, y, z}
                    const sx = (r.Size_Rev.x * GRID_SCALE) - GAP;
                    const sy = (r.Size_Rev.y * GRID_SCALE) - GAP;
                    const sz = (r.Size_Rev.z * GRID_SCALE) - GAP;
                    
                    // Rotation
                    // JSON: p=Pitch(Y), y=Yaw(Z), r=Roll(X)
                    // Three: X, Y, Z radians.
                    const rx = THREE.MathUtils.degToRad(r.Rot_Abs.r || 0);
                    const ry = THREE.MathUtils.degToRad(r.Rot_Abs.p || 0);
                    const rz = THREE.MathUtils.degToRad(r.Rot_Abs.y || 0);
                    
                    // Apply rotation. Order ZYX is common for Euler if not specified.
                    dummy.rotation.set(rx, ry, rz, 'ZYX');
                    dummy.scale.set(sx, sy, sz);
                }
                
                dummy.updateMatrix();
                
                blockMesh.setMatrixAt(globalBlockIdx, dummy.matrix);
                blockMesh.setColorAt(globalBlockIdx, col);
                blockMesh.userData.instanceMap[globalBlockIdx] = meta;
                
                // Text Sprite at Pivot
                addTextSprite(r.Rail_Index.toString(), new THREE.Vector3(cx, cy, cz));
                
                globalBlockIdx++;
            });
            
            blockMesh.instanceMatrix.needsUpdate = true;
            if (blockMesh.instanceColor) blockMesh.instanceColor.needsUpdate = true;

            // 5.6.4 填充箭头与拓扑 (Populate Arrows & Topology)
            rails.forEach(r => {
                const railBasis = getRailBasis(r.Rot_Abs || {p:0, y:0, r:0});

                // (A) Entrance
                if (r.Prev_Index !== -1) {
                    const prev = rails.find(x => x.Rail_Index === r.Prev_Index);
                    if (prev) {
                        const connectedExit = prev.Exit.find(e => e.TargetInstanceID === r.Rail_Index);
                        if (connectedExit) {
                            const entPos = new THREE.Vector3(connectedExit.Exit_Pos_Abs.x, -connectedExit.Exit_Pos_Abs.y, connectedExit.Exit_Pos_Abs.z);
                            const entDir = getDirVector(connectedExit.Exit_Dir_Abs);
                            
                            const offset = 8.0;
                            const newOrigin = entPos.clone().sub(entDir.clone().multiplyScalar(offset));
                            
                            addArrowInstance(newOrigin, 4.0, true, entDir, railBasis.up, railBasis.fwd);
                            
                            if (!window.railArrowMap) window.railArrowMap = {};
                            if (!window.railArrowMap[r.Rail_Index]) window.railArrowMap[r.Rail_Index] = [];
                            window.railArrowMap[r.Rail_Index].push(arrowIdx - 1);
                        }
                    }
                }

                // (B) Exits
                r.Exit.forEach(ex => {
                    if (!ex.Exit_Pos_Abs) return;
                    const exPos = new THREE.Vector3(ex.Exit_Pos_Abs.x, -ex.Exit_Pos_Abs.y, ex.Exit_Pos_Abs.z);
                    const exDir = getDirVector(ex.Exit_Dir_Abs);
                    
                    const arrowLen = 4.0;
                    const offset = 8.0;
                    const origin = exPos.clone().sub(exDir.clone().multiplyScalar(arrowLen + offset));
                    
                    addArrowInstance(origin, arrowLen, false, exDir, railBasis.up, railBasis.fwd);
                    
                    if (!window.railArrowMap) window.railArrowMap = {};
                    if (!window.railArrowMap[r.Rail_Index]) window.railArrowMap[r.Rail_Index] = [];
                    window.railArrowMap[r.Rail_Index].push(arrowIdx - 1);
                    
                    // Sphere
                    dummy.scale.set(1, 1, 1);
                    dummy.position.copy(exPos);
                    dummy.rotation.set(0,0,0);
                    dummy.updateMatrix();
                    exitIMesh.setMatrixAt(exitIdx, dummy.matrix);
                    exitIMesh.setColorAt(exitIdx, ex.IsConnected ? colGreenBasic : colRedBasic);
                    exitIdx++;
                });

                // (C) Topology Lines (Keep as regular lines)
                if (r.Prev_Index !== -1) {
                    const prev = rails.find(x => x.Rail_Index === r.Prev_Index);
                    if (prev) {
                        const pts = [
                            new THREE.Vector3(prev.Pos_Abs.x, -prev.Pos_Abs.y, prev.Pos_Abs.z),
                            new THREE.Vector3(r.Pos_Abs.x, -r.Pos_Abs.y, r.Pos_Abs.z)
                        ];
                        const lGeo = new THREE.BufferGeometry().setFromPoints(pts);
                        root.add(new THREE.Line(lGeo, sharedMats.line));
                    }
                }
            });

            scene.add(root);
            setupRaycaster(root);
        }

        // ==========================================
        // 6. 交互与射线检测 (Interaction & Raycaster)
        // ==========================================

        // Raycaster Global State
        let raycaster, mouse, hoverSprite;
        
        // 6.1 射线初始化
        function setupRaycaster(targetRoot) {
            if (!raycaster) {
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                window.addEventListener('mousemove', onMouseMove, false);
            }
            // Reset hover sprite
            if (hoverSprite) {
                scene.remove(hoverSprite);
                hoverSprite = null;
            }
        }

        // 6.2 鼠标移动处理
        function onMouseMove(event) {
            // Normalize mouse
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // 1. Intersect Blocks
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            let foundBlock = null;
            
            for (let i = 0; i < intersects.length; i++) {
                const obj = intersects[i].object;
                // Check InstancedMesh Block
                if (obj.userData.isBlock && obj.userData.instanceMap) {
                    const instanceId = intersects[i].instanceId;
                    if (instanceId !== undefined && obj.userData.instanceMap[instanceId]) {
                        foundBlock = obj.userData.instanceMap[instanceId];
                        break;
                    }
                }
                // Check Text Sprite
                if (obj.userData && obj.userData.isText) {
                    // Find corresponding block data if needed, or just highlight text
                    // For now, let's just use the ID from the text
                    foundBlock = { id: parseInt(obj.userData.id) }; // Partial data
                    break;
                }
            }
            
            // Update Text Highlight
            // Iterate all sprites? No, too slow.
            // We need a way to target the specific sprite.
            // Since we don't have a map from ID to Sprite easily accessible without traversing,
            // let's just rely on the fact that sprites are persistent.
            // Actually, we can just make the hovered sprite yellow.
            
            // Reset previous hover
            if (window.lastHoveredSprite) {
                window.lastHoveredSprite.material.color.set(0xffffff);
                window.lastHoveredSprite.scale.set(8, 8, 1);
                window.lastHoveredSprite = null;
            }
            // Reset Arrow Colors & Scales
            if (window.lastHoveredArrowIndices.length > 0) {
                 // We need access to shaftIMesh and headIMesh to reset color
                 // They are inside buildScene scope. We should expose them or find them.
                 // Finding by name is easiest.
                 const shaft = scene.getObjectByName("ArrowShaftMesh");
                 const head = scene.getObjectByName("ArrowHeadMesh");
                 
                 if (shaft && head) {
                     window.lastHoveredArrowIndices.forEach(idx => {
                         // Reset Color
                         if (window.arrowColorCache && window.arrowColorCache[idx]) {
                             const col = window.arrowColorCache[idx];
                             shaft.setColorAt(idx, col);
                             head.setColorAt(idx, col);
                         }
                         
                         // Reset Matrix (Scale)
                         if (window.arrowMatrixCache) {
                             if (window.arrowMatrixCache['s' + idx]) {
                                 shaft.setMatrixAt(idx, window.arrowMatrixCache['s' + idx]);
                             }
                             if (window.arrowMatrixCache['h' + idx]) {
                                 head.setMatrixAt(idx, window.arrowMatrixCache['h' + idx]);
                             }
                         }
                     });
                     shaft.instanceColor.needsUpdate = true;
                     head.instanceColor.needsUpdate = true;
                     shaft.instanceMatrix.needsUpdate = true;
                     head.instanceMatrix.needsUpdate = true;
                 }
                 window.lastHoveredArrowIndices = [];
                 window.arrowMatrixCache = {}; // Clear matrix cache
            }

            if (foundBlock) {
                // Find the sprite for this block ID
                if (window.spriteMap && window.spriteMap[foundBlock.id]) {
                    const sprite = window.spriteMap[foundBlock.id];
                    sprite.material.color.set(0xffff00); // Yellow
                    sprite.scale.set(12, 12, 1); // Enlarge
                    window.lastHoveredSprite = sprite;
                }
                
                // Highlight Arrows
                if (window.railArrowMap && window.railArrowMap[foundBlock.id]) {
                     const indices = window.railArrowMap[foundBlock.id];
                     const shaft = scene.getObjectByName("ArrowShaftMesh");
                     const head = scene.getObjectByName("ArrowHeadMesh");
                     
                     if (shaft && head) {
                         if (!window.arrowColorCache) window.arrowColorCache = {};
                         // Matrix cache is already initialized/cleared globally or above
                         if (!window.arrowMatrixCache) window.arrowMatrixCache = {}; 

                         const highlightCol = new THREE.Color(0xffff00); // Yellow
                         const tempCol = new THREE.Color();
                         const tempMatrix = new THREE.Matrix4();
                         const tempPos = new THREE.Vector3();
                         const tempQuat = new THREE.Quaternion();
                         const tempScale = new THREE.Vector3();
                         
                         indices.forEach(idx => {
                             // Save original color
                             shaft.getColorAt(idx, tempCol);
                             window.arrowColorCache[idx] = tempCol.clone();
                             
                             // Save & Update Shaft Matrix
                             shaft.getMatrixAt(idx, tempMatrix);
                             window.arrowMatrixCache['s' + idx] = tempMatrix.clone();
                             
                             tempMatrix.decompose(tempPos, tempQuat, tempScale);
                             tempScale.multiplyScalar(2.0); // Scale UP
                             tempMatrix.compose(tempPos, tempQuat, tempScale);
                             shaft.setMatrixAt(idx, tempMatrix);
                             
                             // Save & Update Head Matrix
                             head.getMatrixAt(idx, tempMatrix);
                             window.arrowMatrixCache['h' + idx] = tempMatrix.clone();
                             
                             tempMatrix.decompose(tempPos, tempQuat, tempScale);
                             tempScale.multiplyScalar(2.0); // Scale UP
                             tempMatrix.compose(tempPos, tempQuat, tempScale);
                             head.setMatrixAt(idx, tempMatrix);
                             
                             // Set Highlight Color
                             shaft.setColorAt(idx, highlightCol);
                             head.setColorAt(idx, highlightCol);
                         });
                         shaft.instanceColor.needsUpdate = true;
                         head.instanceColor.needsUpdate = true;
                         shaft.instanceMatrix.needsUpdate = true;
                         head.instanceMatrix.needsUpdate = true;
                         
                         window.lastHoveredArrowIndices = indices;
                     }
                }
                
                // Update Info Panel
                const infoContent = document.getElementById('info-content');
                if (infoContent) {
                    let data = foundBlock;
                    if (!data.type && window.railDataMap) {
                        data = window.railDataMap[foundBlock.id];
                    }
                    
                    if (data && data.type) {
                        // Safe access helpers
                        const px = data.pos ? formatFloat(data.pos.x) : 0;
                        const py = data.pos ? formatFloat(data.pos.y) : 0;
                        const pz = data.pos ? formatFloat(data.pos.z) : 0;
                        
                        const prx = data.pos_rev ? formatFloat(data.pos_rev.x) : 0;
                        const pry = data.pos_rev ? formatFloat(data.pos_rev.y) : 0;
                        const prz = data.pos_rev ? formatFloat(data.pos_rev.z) : 0;
                        
                        // Rot is {p, y, r}
                        const rotP = data.rot ? formatFloat(data.rot.p) : 0;
                        const rotY = data.rot ? formatFloat(data.rot.y) : 0;
                        const rotR = data.rot ? formatFloat(data.rot.r) : 0;
                        
                        const diffVal = data.diff ? formatFloat(data.diff) : 0;

                        infoContent.innerHTML = `
                            <div class="info-row"><span class="info-label">ID:</span><span class="info-val">${data.id}</span></div>
                            <div class="info-row"><span class="info-label">Type:</span><span class="info-val">${data.type}</span></div>
                            <div class="info-row"><span class="info-label">Pos (Abs):</span><span class="info-val">(${px}, ${py}, ${pz})</span></div>
                            <div class="info-row"><span class="info-label">Pos (Rev):</span><span class="info-val">(${prx}, ${pry}, ${prz})</span></div>
                            <div class="info-row"><span class="info-label">Rot (P/Y/R):</span><span class="info-val">(${rotP}, ${rotY}, ${rotR})</span></div>
                            <div class="info-row"><span class="info-label">Diff:</span><span class="info-val">${diffVal}</span></div>
                        `;
                        infoContent.style.display = 'block';
                    }
                }
            } else {
                const infoContent = document.getElementById('info-content');
                if (infoContent) infoContent.style.display = 'none';
            }
        }

        // 6.3 辅助：更新悬浮文本 (未使用但保留)
        function updateHoverText(id, pos) {
            const message = "#" + id;
            
            // Re-enable cache logic just for single active sprite? 
            // Actually, for a single sprite, we can just update canvas.
            // Or use the cache we had but only create ON DEMAND.
            
            if (!hoverSprite) {
                hoverSprite = new THREE.Sprite(new THREE.SpriteMaterial({ color: 0xffffff, depthTest: false }));
                hoverSprite.scale.set(12, 12, 1);
                hoverSprite.renderOrder = 999;
                scene.add(hoverSprite);
            }
            
            // Check if material exists
            if (!sharedMats.boxMatCache["txt_" + message]) {
                 const canvas = document.createElement('canvas');
                 const ctx = canvas.getContext('2d');
                 canvas.width = 128;
                 canvas.height = 128;
                 ctx.font = "Bold 60px Arial";
                 ctx.fillStyle = "white";
                 ctx.textAlign = "center";
                 ctx.textBaseline = "middle";
                 ctx.strokeStyle = "black";
                 ctx.lineWidth = 4;
                 ctx.strokeText(message, 64, 64);
                 ctx.fillText(message, 64, 64);
                 
                 const texture = new THREE.CanvasTexture(canvas);
                 const mat = new THREE.SpriteMaterial({ map: texture, depthTest: false });
                 sharedMats.boxMatCache["txt_" + message] = mat;
            }
            
            hoverSprite.material = sharedMats.boxMatCache["txt_" + message];
            hoverSprite.visible = true;
            hoverSprite.position.copy(pos).add(new THREE.Vector3(0, 0, 10));
        }

        // 6.4 辅助：方向向量转换
        function getDirVector(dirStr) {
            // UE: +Y is Right.
            // Three (Y-flipped): Right is -Y.
            if (dirStr === "+X") return new THREE.Vector3(1, 0, 0);
            if (dirStr === "-X") return new THREE.Vector3(-1, 0, 0);
            if (dirStr === "+Y") return new THREE.Vector3(0, -1, 0); // Flip Y
            if (dirStr === "-Y") return new THREE.Vector3(0, 1, 0);  // Flip Y
            if (dirStr === "+Z") return new THREE.Vector3(0, 0, 1);
            if (dirStr === "-Z") return new THREE.Vector3(0, 0, -1);
            return new THREE.Vector3(0, 0, 1);
        }

        // ==========================================
        // 7. 渲染循环 (Render Loop)
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        // 7.1 窗口调整事件
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>